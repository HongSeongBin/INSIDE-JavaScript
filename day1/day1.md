## Chapter 03 자바스크립트 데이터 타입과 연산자


#### 자바스크립트 데이터 타입  

* 기본 타입 - Number, String, Boolean, undefined, null
* 참조 타입 - Object (Array, Function, 정규표현식)

<br/>


#### 자바스크립트 기본 타입


: 느슨한 타입 체크 언어로 변수를 선언할 때 타입을 미리 정하지 않고 , var이라는 한가지 키워드로만 변수를 선언해. 여기에는 어떤 데이터라도 저장하는 것이 가능한거지. 

 즉, 자바스크립트는 변수에 어떤 혀앹의 데이터를 저장하느냐에 따라 해당 변수의 타입이 결정되
 
<br/>


#### Number

: 자바스크립트는 정수형이 따로 없고, 모든 숫자를 실수로 처리.

  ( 그렇기에 나눗셈 연산에서 c랑 다른 결과값이 나오기에 주의)
  
<br/>


#### 문자열

: " 혹은 ' 로 정의하는데 중요한것은 정의된 문자열은 변하지 않아!

  즉 자바스크립트에서는 한 번 생성된 문자열은 읽기만 가능하고 수정 불가
  
<br/>


#### null vs undefined

: 이 두 타입 모두 자바스크립트에서 값이 비어있음을 나타내. 

  자바스크립트 환경 내에서 기본적으로 값이 할당되지 않은 변수는 undefined 타입이며 값 또한 undefined이야.

  null 타입 변수의 경우는 개발자가 명시적으로 값이 비어있음을 나타내는 데 사용해.

  참고로 null은 Object 타입이기에 비교할 때 typeof가 아닌 일치연산자(===)를 사용해야해.
  
<br/>


#### 자바스크립트 참조타입

: 자바스크립트에서는 기본타입을 제외한 모든 값은 객체야. 자바스크립트에서 객체란 'key : value' 형태의 프로퍼티들을 저장하는 컨테이너라고 생각하면 돼.

 기본타입은 하나의 값만 가지지만 참조타입인 객체는 여러 개의 프로퍼티들을 포함할 수 있고 또 이러한 객체의 프로퍼티는 기본타입의 값을 포함하거나, 다른 객체를 가리킬 수도 있어.
<br/>


#### 객체 생성

1. 자바스크립트 내장되어 기본제공되는 Obeject() 객체 생성자 함수 이용

2. 객체 리터럴 ( {}이용 )

3. 생성자 함수

<br/>


#### 객체 property 읽기/쓰기/갱신 

접근 방법에는 크게 두가지가 있어.

1) 대괄호( [ ] ) 표기법      2) 마침표 ( . ) 표기법

편한거 사용하면 되긴 하지만 주의할 점이 property가 'full-name' 이런 형태라면 마침표 표기법을 이용하면 - 연산이 일어날 수도 있기에 이럴 경우 대괄호 표기법을 사용해야해.

<br/>


#### for in

: for in 문을 이용하면 객체의 모든 property에 순차적으로 접근할 수 있어.

 자바스크립트에서는 배열도 객체로 구분하는데 이 때 배열 내부의 값만 접근하고프다면

  for in 보다는 length를 이용한 for문이 좋아! (배열의 출력을 원하지않는 프로퍼티가 출력될수도..)

<br/>



#### 객체 비교

: 동등 연산자 (==)를 사용하여 두 객체를 비교할 때도 객체의 프로퍼티 값이 아닌 참조값을 비교해!!

  → 값이 동일하더라도 참조하는 녀석이 다르다면 false를 반환하게 되는거지!

<br/>


#### 참조에 의한 함수 호출 방식

*기본 타입 : Call by value

*참조 타입 : Call by reference

<br/>


#### 프로토타입

(처음 알게된 내용이니까 자세히 보자!!)

자바스크릡트의 모든 객체는 자신의 부모 역할을 하는 객체와 연결되어있어. 그래서 이를 이용해 상속 개념처럼 사용할 수 있게 되는거지.

이런 부모 객체를 자바스크립트에서는 프로토타입 객체라고 불러.

자바스크립트의 모든 객체는 자신의 프로토타입을 가리키는 숨겨진 property를 가지고 있어.

객체.toString() 같은 메소드를 이용할 수 있는 것도 다 그런 이유에서 가능한거야!

<br/>


#### 배열 length property

: length property는 배열의 원소 개수를 나타냈으나 꼭 배열에 존재하는 원소개수와 일치하는 것은 아니야. undefined로 값이 존재하지 않아도 length property에는 count 되는거지.

→ 배열의 사이즈는 length property+1이 된다 생각하면 돼.

그렇기에 기존에 명시 해 놓은 배열 사이즈보다 더 적게 length를 변경시킨다면 배열의 뒷부분이 삭제될 수도 있어.

<br/>


#### 배열과 객체

이 둘 모드 Object이나 차이가 존재해.

객체의 프로토타입과 배열의 프로토타입을 보자.

객체 → Object.prototype

배열 → Array.prototype → Object.prototype

이런 구조로 되어있는거야!!

→ 아~ 그래서 같은 객체이나 사용할 수 있는 메소드들이 다른 거 였구나!!



#### 배열의 property 동적 생성

물론 배열도 Object 이기에 property를 추가해줄 수 있어. 하지만 그렇게 해서 추가하더라도

배열의 length에는 영향을 끼치지 않아!

<br/>


#### 배열요소 삭제

1) delete : 해당하는 배열의 요소를 삭제하고 그 곳에 undefined 를 할당. length에는 변화x

                ( ex) delete arr[2] ; )

2) splice : 해당하는 배열의 요소를 삭제하고 length 도 줄여줘

<br/>


#### Array() 생성자 함수

: 호출할 때 인자 1개이고 숫자일 경우 호출된 인자를 length로 갖는 빈 배열 생성해줘

  그 외의 경우라면 호출된 인자를 요소로 갖는 배열 생성해주는거야.

  ex) ( var foo = new Array(3);   , var bar = new Array(1,2,3) ; )
  
<br/>


#### 유사 배열 객체

: length 프로퍼티를 가진 배열이 아닌 객체를 유사 배열 객체라고 해!

유사 배열 객체의 가장 큰 특징은 배열 객체가 아님에도 불구하고, 자바스크립트의 표준 배열 메서드를 사용하는게 가능하단 거야.

<br/>


#### 기본 타입과 표준 메서드

: 그럼 기본타입은 객체가 아닌데 어떻게 메서드를 호출하는 겨??

  → 기본타입의 값들에 대해 객체 형태로 메서드를 호출할 경우, 이들 기본값은 메서드 처리 순간에 객체로 변환된 다음 각 타입별 표준메서드를 호출하게 되고 그 이후에 다시 기본값으로 복귀!!
  
<br/>


#### typedef 연산자

문자열 - string

숫자 - Number

불린값 - boolean

null - object

undefined - undefined

객체 - object

배열 - object

함수 - function

<br/>


#### ==(동등) 연산자 vs ===(일치) 연산자

1) ==연산자 : 비교하려는 피연산자의 타입이 다를 경우에 타입 변환를 거친다음 비교진행

2) ===연산자 : 피연산자의 타입이 다르더라고 타입변경을 하지 않고 비교해.

<br/>


#### !!연산자

: 피연산자를 불린값으로 변환하는거야!!

  흠... 이건 어디에 쓸려고 있는걸까...

<br/>


## Chapter4 함수와 프로토타입 체이닝


#### 함수정의

: 자바스크립트에서 함수를 생성하는 방법은 3가지야. 이에 따라 미묘~하게 동작이 차이가 난데.

 1) 함수 선언문      2) 함수 표현식     3) Function() 생성자 함수
 
<br/>


#### 함수 리터럴

: 자바스크립트에서는 함수도 일반 객체처럼 값으로 최급돼!! wow... 때문에 객체 리터럴 방식으로 일반 객체를 생성할 수 있는 것 처럼, 자바스크립트에서는 함수리터럴을 이용해 함수를 생성할 수 있어.

실제 함수 선언문이나 함수 표현식 방법 모두 이런 함수 리터럴 방식으로 함수를 생성한다 이말이야!

ex) function add(x,y){ return x+y; }

(자바스크립트에서 함수명은 명시를 안해줘두 돼!! → 익명함수가 되는거지)
