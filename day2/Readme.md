#### 함수를 리턴하는 함수

: 함수도 일급객체라고 했자나. 그래서 일반 값처럼 함수 자체를 리턴할 수도 있어. 

여기에서 오는 특징이 함수를 호출함과 동시에 다른 함수로 바꾸거나, 자기 자신을 재정의 하는 함수를 구현할수도 있게되는거야

<br/>


#### arguments 객체

: 자바스크립트에는 arguments라는 객체가 있어. 자바스크립트 함수에는 인자의 갯수를 함수의 정의에서 정해준 것 보다 더 많이 주던 더 적게 주던 에러가 발생하지 않아!

그게 바로 arguments 객체 덕분이야. arguments 객체는 함수를 호출할 때 넘긴 인자들이 배열 형태로 저장된 객체를 의미해. 특이한 것은 정확히는 **유사 배열 객체** 라는 점이지!

그렇기에 배열 메서드를 이용할 수 없음을 주의해야해. 이 arguments 객체를 이용하면 매개변수가 정확하게 정해지지 않은 함수를 구현하거나, 전달된 인자의 개수에 따라 서로 다른 처리를 해줘야 하는 함수를 개발하는 데 유용하게 사용할 수 있어.
```javascript
function sum(){
var result = 0;

for(var i=0 ; i<arguments.length ; i++){
  result += arguments[i];
  }
  
  return result;
}
```
이런식으로 말야!!

<br/>


#### 호출패턴과 this 바인딩

: 함수를 호출할 때 기존 매개변수로 전달되는 인자값에 더해서 앞에서 설명한 arguments 객체와 this 인자가 함수내부로 암묵적으로 전달되어져!

이 this 인자를 이해하는 것이 중요하데. 얘는 함수가 호출되는 방식(호출패턴)에 따라 this가 다른 객체를 참조하기 때문이야.

* 객체의 메서드를 호출할 때 this 바인딩 : 객체의 프로퍼티가 함수인 경우 이를 메소드라고 한다 했자나. 이 메소드 내부 코드에서 사용된 this는 해당 메소드를 호출한 객체로 바인딩 되!
* 함수를 호출할 때 this 바인딩 : 자바스크립트에서는 함수를 호출하면, 해당 함수 내부 코드에서 사용된 this는 **전역 객체**에 바인딩 되! 브라우저에서 자바스크립트를 이용할 경우 window가 전역객체가 되겠지. 여기서 알고 넘어가야 할 것은 내부함수를 호출하였을 때야. 특정 객체의 메소드 내부에 내부함수가 정의되어있다 생각해보자. 그 내부 함수에서 this를 사용할 경우 부모함수를 호출한 객체를 가르키지 않을까 생각할 수 있지만 그렇지 않아! 내부함수도 함수로 처리되기에 this로 접근할 경우 전역객체에 접근하게 되는거야. 이를 방지하고 싶다면 다른 참조변수를 이용하면 되는데 보통은 that 으로 이름을 많이 짓는데!! 그래서 부모 함수에서 that = this; 를 통해 that이 this를 참조하게 한후 그 내부 함수에서는 that을 통해 접근한다면 전역객체가 아닌 부모 함수를 호출한 객체에 접근할 수 있게 되는거지!!
* 생성자 함수를 호출할 때 this 바인딩 : 기존 함수에 new 연산자를 붙여서 호출하면 해당 함수는 생성자 함수로 동작해. 이는 어떻게보면 일반 함수에 new를 붙여 호출하면 원치 않는 생성자 함수처럼 동작할 수 있다는거지. 그래서 자바스크립트 스타일 가이드에서는 생성자 함수로 특정함수가 정의되어 있음을 알리기 위해 함수 이름의 첫 문자를 대문자로 쓰기를 권해. 생성되는 과정은 다음과 같아. new 연산자로 함수를 생성자로 호출 -> 빈 객체가 생성되고 이 객체는 this로 바인딩 -> 함수 코드 내부에서 this 를 이용해 동적으로 프로퍼티나 메서드 생성 -> 생성된 객체 리턴

